python_script:
  requirements:
    - cryptocode
    - requests
    - pytz
    - DateTime

sensor:
- platform: python_script
  name: reolink_events
  scan_interval: '00:01:00'
  login_reolink: login_reolink
  pass_reolink: pass_reolink
  ip_reolink: ip_reolink
  stream_type: sub # main or sub
  source: |
    import requests
    from datetime import datetime, timedelta
    import pytz
    import cryptocode

    start = datetime.today() - timedelta(days=1)
    end = datetime.now()

    login_reolink = self.config['login_reolink']
    pass_reolink = self.config['pass_reolink']
    ip_reolink = self.config['ip_reolink']
    stream_type = self.config['stream_type']

    with open('/config/secrets.yaml') as f:
      for line in f:
        if line.split(":")[0] == login_reolink:
          login_reolink = line.replace("login_reolink: ","").replace("\n","").replace(" ","")
        if line.split(":")[0] == pass_reolink:
          pass_reolink = line.replace("pass_reolink: ","").replace("\n","").replace(" ","")
        if line.split(":")[0] == ip_reolink:
          ip_reolink = line.replace("ip_reolink: ","").replace("\n","").replace(" ","")

    url = "http://" + ip_reolink + "/cgi-bin/api.cgi"

    to_sensor = "sensor.to_reolink_" + str(ip_reolink.replace(".", "_"))
    to_sensor_name = to_sensor.split('.')[1]
    token = ''
    token_shf = ''
    headers = {'content-type': 'application/json'}
    shf = "dwk" # ключ для шифрования токена в сенсоре

    search_params = {
                'Search': {
                    'channel': 0,
                    'streamType': stream_type,
                    'onlyStatus': 0,
                    'StartTime': {
                        'year': start.year,
                        'mon': start.month,
                        'day': start.day,
                        'hour': start.hour,
                        'min': start.minute,
                        'sec': start.second
                    },
                    'EndTime': {
                        'year': end.year,
                        'mon': end.month,
                        'day': end.day,
                        'hour': end.hour,
                        'min': end.minute,
                        'sec': end.second
                    }
                }
            }
    command = [{"cmd": "Search", "action": 1, "param": search_params}]

    tries = 2
    for i in range(tries):
      try:
        token_shf = self.hass.states.get(to_sensor).state
        assert(token_shf is not None)
        token = cryptocode.decrypt(token_shf, shf)
        assert(token)

        params = {"token": token, 'cmd': command}
        response = requests.post(url, verify=False, params=params, json=command, headers=headers)

        events = response.json()[0]['value']['SearchResult']['File'][-10:]

        processed_motions = []
        replace_fields = {'mon': 'month', 'sec': 'second', 'min': 'minute'}
        for file in events:
            time_range = {}
            for x in ['Start', 'End']:
                raw = file[f'{x}Time']
                for k, v in replace_fields.items():
                    if k in raw.keys():
                        raw[v] = raw.pop(k)
                time_range[x.lower()] = datetime(**raw)
            start, end = time_range.values()
            processed_motions.append({
                        'start': pytz.utc.localize(start),
                        'end': pytz.utc.localize(end),
                        'filename': file['name']
                    })

      except Exception as e:
        if i < tries - 1:
          i +=1
          logger.warning("sensor.reolink получение токена для " + str(ip_reolink))

          body = [{"cmd": "Login", "action": 0, "param": {"User": {"userName": login_reolink, "password": pass_reolink}}}]
          param = {"cmd": "Login", "token": "null"}
          response = requests.post(url, verify=False, params=param, json=body, headers=headers)
          token = response.json()[0]["value"]["Token"]["name"]
          token_shf = cryptocode.encrypt(token,shf)

          attr = {}
          attr["friendly_name"] = to_sensor_name
          self.hass.states.set(to_sensor, token_shf, attr)
          continue
        else:
          raise
      break


    self.state = processed_motions[9]['filename']
    self.attributes={}
    self.attributes['file'] = processed_motions



script:
  reolink_download_file:
    alias: Загрузка видео с камеры Reolink
    mode: parallel
    max: 10
    fields:
      name_file:
        description: Имя файла на камере для загрузки
        required: true
        example: video.mp4
        default: video.mp4
        selector:
          text: null
      local_folder:
        description: Локальная папка для загрузки
        required: true
        example: /config/downloads
        default: /config/downloads
        selector:
          text: null
      login_reolink:
        description: Логин от камеры, необходимо указать имя секрета в файле secrets.yaml
        required: true
        example: login_secret
        default: login_secret
        selector:
          text: null
      pass_reolink:
        description: Пароль от камеры, необходимо указать имя секрета в файле secrets.yaml
        required: true
        example: pass_secret
        default: pass_secret
        selector:
          text: null
      ip_reolink:
        description: IP камеры, необходимо указать имя секрета в файле secrets.yaml
        required: true
        example: ip_secret
        default: ip_secret
        selector:
          text: null

    sequence:
        - service: python_script.exec
          data: 
            cache: false
            name_file: '{{name_file}}'
            local_folder: '{{local_folder}}'
            login_reolink: '{{login_reolink}}'
            pass_reolink: '{{pass_reolink}}'
            ip_reolink: '{{ip_reolink}}'
            source: |
                import requests
                import cryptocode

                name_file = data["name_file"]
                local_folder = data["local_folder"]

                login_reolink = data["login_reolink"]
                pass_reolink = data["pass_reolink"]
                ip_reolink = data["ip_reolink"]

                with open('/config/secrets.yaml') as f:
                    for line in f:
                        if line.split(":")[0] == login_reolink:
                            login_reolink = line.replace("login_reolink: ","").replace("\n","").replace(" ","")
                        if line.split(":")[0] == pass_reolink:
                            pass_reolink = line.replace("pass_reolink: ","").replace("\n","").replace(" ","")
                        if line.split(":")[0] == ip_reolink:
                            ip_reolink = line.replace("ip_reolink: ","").replace("\n","").replace(" ","")

                url = "http://" + ip_reolink + "/cgi-bin/api.cgi"
                to_sensor = "sensor.to_reolink_" + str(ip_reolink.replace(".", "_"))
                to_sensor_name = to_sensor.split('.')[1]
                token = ''
                token_shf = ''
                folder_file = local_folder + '/' + name_file
                headers = {'content-type': 'application/json'}
                shf = "dwk" # ключ для шифрования токена в сенсоре

                tries = 2
                for i in range(tries):
                    try:

                      token_shf = hass.states.get(to_sensor).state
                      assert(token_shf is not None)
                      token = cryptocode.decrypt(token_shf, shf)
                      assert(token)
                      params = {"token": token, 'cmd': 'Download'}
                      body = [
                                  {
                                      "cmd": "Download",
                                      "source": name_file,
                                      "output": name_file,
                                      "filepath": local_folder
                                  }
                              ]
                      params.update(body[0])

                      with requests.get(url, params=params, stream=True, verify=False, timeout=(1, None)) as req:
                          with open(folder_file, 'wb') as f:
                              f.write(req.content)

                    except Exception as e:
                        if i < tries - 1:
                            i +=1
                            logger.warning("script.reolink получение токена для " + str(ip_reolink))

                            body = [{"cmd": "Login", "action": 0, "param": {"User": {"userName": login_reolink, "password": pass_reolink}}}]
                            param = {"cmd": "Login", "token": "null"}
                            response = requests.post(url, verify=False, params=param, json=body, headers=headers)
                            token = response.json()[0]["value"]["Token"]["name"]
                            token_shf = cryptocode.encrypt(token,shf)

                            attr = {}
                            attr["friendly_name"] = to_sensor_name
                            hass.states.set(to_sensor, token_shf, attr)
                            continue
                        else:
                            raise
                    break
